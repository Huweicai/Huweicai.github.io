<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Anonymous&#39; Blog</title>
    <link>https://huweicai.com/blog/</link>
    <description>Recent content in Blogs on Anonymous&#39; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Fri, 29 May 2020 19:58:00 +0800</lastBuildDate>
    
	<atom:link href="https://huweicai.com/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang 如何排查协程泄漏问题</title>
      <link>https://huweicai.com/troubleshotting-goroutine-leeking/</link>
      <pubDate>Fri, 29 May 2020 19:58:00 +0800</pubDate>
      
      <guid>https://huweicai.com/troubleshotting-goroutine-leeking/</guid>
      <description>背景 周所周知，内存泄漏是一个很严重的问题，会导致系统运行占用资源越来越多，无法释放，直至崩溃。所幸 Go 语言是一门 具有垃圾回收的语言，能大大降低遇到内存泄漏的概率，而我们今天要说的是另外一个棘手的问题：协程泄漏。 协程泄漏：顾名思义就是出现了应该释放而没有被释放的协程，导致系统协程数量一直上升。不像对象回收需要引用计数、三色标记等手段，协程的回收是相当简单的，等待协程将代码从头到尾执行完毕之后这一块儿空</description>
    </item>
    
    <item>
      <title>颜色是如何呈现的</title>
      <link>https://huweicai.com/how-color-present/</link>
      <pubDate>Thu, 09 Apr 2020 01:27:11 +0800</pubDate>
      
      <guid>https://huweicai.com/how-color-present/</guid>
      <description>现实的世界是丰富多彩的，然而我们又是怎么将这种色彩呈现到我们的显示器上的呢？ 人眼如何感知色彩 众所周知，光是一种电磁波，可见光是人眼所能处理的一个电磁波频率区间子集，人眼看到事物是通过光来感知的，颜色的本质就是电磁波的频率，不同频率的光即我们语言中所定义的不同种类的颜色。本质上我们的眼睛和雷达并没有任何区别，只是大脑的解码渲染能力强一点罢了。 人的眼睛中有视锥细胞和视杆细胞，视杆细胞负责感受光的强度，</description>
    </item>
    
    <item>
      <title>找出使用最频繁的Shell命令</title>
      <link>https://huweicai.com/most-frequently-command/</link>
      <pubDate>Fri, 20 Mar 2020 19:58:00 +0800</pubDate>
      
      <guid>https://huweicai.com/most-frequently-command/</guid>
      <description>使用最频繁 TOP 10命令： history | awk &amp;#39;{map[$2]++} END { for (a in map )print map[ a ]&amp;#34; &amp;#34; map[ a ]/NR*100 &amp;#34;% &amp;#34; a }&amp;#39; | column -c3 -s &amp;#34; &amp;#34; -t |sort -nr | nl | head -n10 先上成品，然后，我们一步一步分析这行语句都涉及到了命令，它们又是如何拼凑到一块儿完成我们的目的的。 Shell 首先我们需要明确一下 shell 的定义，大家可能经常听到 shell ，shell 脚本这些词，那么 shell 到底是什么呢？ Shell 翻译成中文的意思就是壳，和操作系统内核的核相对应，就是一个基于内核的可操作界面。可操作性界面又分为两种： 图形界面</description>
    </item>
    
    <item>
      <title>Redis FAQ</title>
      <link>https://huweicai.com/redis-faq/</link>
      <pubDate>Sat, 04 Jan 2020 22:43:00 +0800</pubDate>
      
      <guid>https://huweicai.com/redis-faq/</guid>
      <description>简单翻译Redis官网的FAQ以及部分自己总结的问题 官网FAQ地址 Redos持久化策略：RDB和AOF RDB：数据快照，数据整体快照，吞吐量较大，但单次耗时较长，如果在dump的时候宕机可能会导致数据丢失。 AOF：日志追加，占空间比RDB大，但安全性更好，每秒追加一次日志，丢失数据的可能性会小很多，但是宕机恢复很慢。 而在实际生产环境中，我们通常会将两种持久化策略共同使用，定期进行数据快照，同时保留</description>
    </item>
    
    <item>
      <title>Go 多路条件语句 Switch 语法详解&#34;</title>
      <link>https://huweicai.com/go-switch/</link>
      <pubDate>Thu, 02 Jan 2020 12:09:00 +0800</pubDate>
      
      <guid>https://huweicai.com/go-switch/</guid>
      <description>Switch 是 Go 语言中一种多路条件语句，一般搭配 case 语句使用。 执行逻辑 一个 switch case 条件结构如下所示： switch simpleStatement; condition { case expression1,expression2: statements case expression3: statements default: statements } 和 if 语句类似，switch 语句也可以在条件语句之前执行一段简短的表达式（可以用于很方便的控制变量的作用域），switch case 开始执行时，会先执行这一个表达式（空也算一种），然后计算出条件语句的值，接着按从上到下，从左到右的顺序一个一个的执行 case 语句的条件表达式，如果值相等的话就会进入执行 case 条件</description>
    </item>
    
    <item>
      <title>在线 Markdown 转 PDF 工具评测</title>
      <link>https://huweicai.com/web-markdown-to-pdf-utils/</link>
      <pubDate>Tue, 02 Jul 2019 08:47:11 +0800</pubDate>
      
      <guid>https://huweicai.com/web-markdown-to-pdf-utils/</guid>
      <description>用 Markdown 写了这么久博客，对于这种简约风格还是非常喜欢的，所以在写一些其他文档的时候我也更倾向于这种格式。最近需要写一些 PDF 格式的文档，所以我找了一些在线 Markdown 转 PDF 的网站，不同的网站渲染出来的风格并不一样，我在下面做了一个对比，帮助大家进行选择。 测试数据 # 测试测试 1111111111 / 测试 / 123 Email: test@test.com Test: test Website: https://github.com.cn * * * 123213123 测出测试 真的测试 测试吧 * * * # 二阶段测试 - 真的测试测试 - 真的测试测试/真的测试测试 - 微博：[@Easy](http:</description>
    </item>
    
    <item>
      <title>Java跨平台究竟能跨哪些平台</title>
      <link>https://huweicai.com/java-platforms/</link>
      <pubDate>Mon, 20 May 2019 23:47:00 +0800</pubDate>
      
      <guid>https://huweicai.com/java-platforms/</guid>
      <description>众所周知，Java跨平台的一直被众多Java程序员们津津乐道，“一次编写，到处运行”的设想着实令人心动，虽然会带来一定性能上的问题，但这并不妨碍大家对Java的喜爱，既然都说Java能跨平台，Java 也并不是凭空就能跑在任何机器上，这是不现实的，需要官方针对对应的平台，编译一套对应平台包括 Java 虚拟机（Java Runtime Environment 简称 JRE）在内的 Java 开发工具集（Java Develop Kit，简称 JDK），这样我们编写的 Java 代码才算</description>
    </item>
    
    <item>
      <title>小论计算机Encoding</title>
      <link>https://huweicai.com/computer-encodings/</link>
      <pubDate>Sat, 26 May 2018 12:47:11 +0800</pubDate>
      
      <guid>https://huweicai.com/computer-encodings/</guid>
      <description>乱码问题一直是最让人心烦的一类问题，因为不知从何而来，由何而起，只能一处一处的改编码，运气好了就改成功了，运气不好就继续试，有时候明明把所有能改的地方全改成UTF-8了，却仍然无济于事，着实叫人抓狂。这一切都要从1946年的那个春天说起。 在第一计算机台诞生的时候，那个时候还只有0和1，慢慢的，科学家们厌倦了只有0和1的世界，所以他们就聚在一起开了个会，讨论了讨论，决定按特定的方式将人类语言映射到0</description>
    </item>
    
    <item>
      <title>for{;;}与while(true)的困惑</title>
      <link>https://huweicai.com/confusion-betwwen-forwhiletrue/</link>
      <pubDate>Sun, 04 Mar 2018 21:47:00 +0800</pubDate>
      
      <guid>https://huweicai.com/confusion-betwwen-forwhiletrue/</guid>
      <description>最近在阅读JUC源码的时候，由于多线程并发时情况比较复杂，所以源码中经常出现一些无限循环用于等待确保或是某些目的的完成，通常我一般无限循环都是用while(true)，但是我发现在concurrent包中经常用for(;;)来实现。这让我产生了困惑，难道for(;;)会比while(true)性能更好一些吗？于是我决定自己分别编译比较一下。 我编写了如下的程序： public class Test2 { public void whileTest() { int i = 0; while (true) { i++; } } public</description>
    </item>
    
    <item>
      <title>完整网络请求包自底向上分析</title>
      <link>https://huweicai.com/who-network-capture-analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huweicai.com/who-network-capture-analysis/</guid>
      <description>我们都知道网络是分层的，HTTP 请求包发出的时候会一层一层往下叠加头部知道最终变成物理信号在网线上传输，那么最终的网络包到底是长什么样呢？我们今天就来实践探索一下。 先在服务器上起一个简单的 HTTP 服务： python -m SimpleHTTPServer 8001 然后在客户端发起一个无参数的 GET 请求访问其根目录： curl -v http://110.89.228.110:8001 同时我们用 WireShark 抓包，完整的从网卡出去的一个包是长这样的一串二进制流： 011110001100001100010011100101011111011110000010100010001110100111111110011001111011 110001111100000010000000000001000101000000000000000010000111000000000000000001000000 000000000100000000000110000111011111011011000000101010000000000100000100011101100101 100111100100011101011100100000000111000111110100000100000010011101011110001011010011 100100011011000011111010111111111000000000011000000010000000001101001101001000110000 000000000000000000010000000100001000000010100010110011111101011000011100011110010101 011010110101010110010001010001110100010101010100001000000010111100100000010010000101 010001010100010100000010111100110001001011100011000100001101000010100100100001101111 011100110111010000111010001000000011000100110001001110000010111000111000001110010010 111000110010001100100011100000101110001100010011000100110111001110100011100000110000 001100000011000100001101000010100101010101110011011001010111001000101101010000010110 011101100101011011100111010000111010001000000110001101110101011100100110110000101111 001101110010111000110110001101000010111000110001000011010000101001000001011000110110 001101100101011100000111010000111010001000000010101000101111001010100000110100001010 0000110100001010 这串二进制流就是要在网线上传输的原始信号，如果</description>
    </item>
    
  </channel>
</rss>