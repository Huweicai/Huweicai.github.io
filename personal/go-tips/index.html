<!DOCTYPE html>
<html lang="zn-Hans">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, maximum-scale=1" />
  <meta name="author" content="Huweicai">
  <meta name="description" content="Pool go struct能不能比较 go defer 的实现原理 select 多个条件满足时会走哪一个分支 实现消息队列（多生产者，多消费者） go gc 算法 go 协程调度模型：MPG go 反射实现原理 sync.Pool 实现原理 goroutine调度用了什么系统调用 什么是闭包 for i 遍历和 for range 遍历有什么区别 后者是前者的语法糖，编译在编译的时候还是会转化成 for i 的方式。 for v1,v2 := range ha 遍历数组的实际运行格式： ha := a hv1 := 0 hn := len(ha) v1 := hv1 for ; hv1 &lt; hn; hv1&#43;&#43; { tmp := ha[hv1] v1, v2 := hv1, tmp ... } for hv1 := range h1 遍历">
  
  <meta property="og:title" content="Go语言小知识" />
<meta property="og:description" content="Pool go struct能不能比较 go defer 的实现原理 select 多个条件满足时会走哪一个分支 实现消息队列（多生产者，多消费者） go gc 算法 go 协程调度模型：MPG go 反射实现原理 sync.Pool 实现原理 goroutine调度用了什么系统调用 什么是闭包 for i 遍历和 for range 遍历有什么区别 后者是前者的语法糖，编译在编译的时候还是会转化成 for i 的方式。 for v1,v2 := range ha 遍历数组的实际运行格式： ha := a hv1 := 0 hn := len(ha) v1 := hv1 for ; hv1 &lt; hn; hv1&#43;&#43; { tmp := ha[hv1] v1, v2 := hv1, tmp ... } for hv1 := range h1 遍历" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://huweicai.com/personal/go-tips/" />
<meta property="article:published_time" content="2020-08-19T19:58:00+08:00" />
<meta property="article:modified_time" content="2020-08-19T19:58:00+08:00" />

  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-175035126-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-175035126-1');
</script>

  <title>
  
       Go语言小知识 | Anonymous&#39; Blog 
  
  </title>

  <link rel="canonical" href="https://huweicai.com/personal/go-tips/">

  
  

  
  <link href="https://huweicai.com/css/vendors-extensions/fontawesome/all.min.css" rel="stylesheet">

  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:300,400,500,600">
  <link href="https://huweicai.com/css/font.css" rel="stylesheet"> 
    
  
  <link href="https://huweicai.com/css/vendors/bootstrap4/bootstrap.min.css" rel="stylesheet">
  <link href="https://huweicai.com/css/vendors-extensions/mdb/mdb.min.css" rel="stylesheet"> 
  <link href="https://huweicai.com/css/vendors/mdb/style.min.css" rel="stylesheet"> 
  <link href="https://huweicai.com/css/main.css" rel="stylesheet">


  
  <link rel="shortcut icon"
  
      href="https://cdn.jsdelivr.net/gh/Huweicai/Huweicai.github.io/img/logo.png"
  
  >


  
  

  <style type="text/css">
      @media (min-width: 800px) and (max-width: 850px) {
              .navbar:not(.top-nav-collapse) {
                  background: #1C2331!important;
              }
          }
  </style>


  
    
    <link rel="stylesheet" href="https://huweicai.com/js/vendors/katex/katex.min.css">
  
  

  
    
    <link rel="stylesheet" href="https://huweicai.com/css/vendors/highlight/github-gist.css">
  

</head>

  <body class="bg-light" data-spy="scroll" data-target="#page-scrollspy" data-offset="90">
  
    
    

    
      


<nav class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar">
    <div class="container">

      
      <a class="navbar-brand" href="https://huweicai.com">
          
        <img class="avatar" src="https://cdn.jsdelivr.net/gh/Huweicai/Huweicai.github.io/img/logo.png" style="width: 40px!important;height: auto;"  class="d-inline-block align-top" alt="" >
        
        <strong> Huweicai</strong>
      </a>

      
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
        aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      
      <div class="collapse navbar-collapse" id="navbarSupportedContent">

        
        <ul class="navbar-nav mr-auto ">
          <li class="nav-item ">
            <a class="nav-link" href="https://huweicai.com">Home</a>
          </li>
             
            <li class="nav-item ">
              <a class="nav-link" href="https://huweicai.com/about/" >About  </a>
            </li>
          
          
        </ul>

      </div>

    </div>
  </nav>
  
 
      
 






<div id="site-header" class="carousel slide carousel-fade" data-ride="carousel" style="height: 18rem;" >  

  
  
  

  
  <div class="carousel-inner" role="listbox">
    
      

        
        <div class="carousel-item active">
          <div class="view" style="background-image: url('https://cdn.jsdelivr.net/gh/Huweicai/Huweicai.github.io/img/header-slides/raw_1515147341.jpg'); background-repeat: no-repeat; background-size: cover;">

            
            <div class="mask rgba-black-light d-flex justify-content-center align-items-center">

              
              
              

            </div>
            

          </div>
        </div>
        
      
    
      

        
        <div class="carousel-item">
          <div class="view" style="background-image: url('https://cdn.jsdelivr.net/gh/Huweicai/Huweicai.github.io/img/header-slides//raw_1515691746.jpg'); background-repeat: no-repeat; background-size: cover;">

            
            <div class="mask rgba-black-light d-flex justify-content-center align-items-center">

            

            </div>
            

          </div>
        </div>
        
      
    

  
  </div>
  

  
  <div class="carousel-content text-center white-text wow fadeIn">
    <div class="row mx-0 headfont mt-3 pt-4">
      
      <div class="col-12 col-sm-5 align-middle">
        <a href="https://huweicai.com">
          
            <img class="pull-right avatar avatar-md" src="https://cdn.jsdelivr.net/gh/Huweicai/Huweicai.github.io/img/profile.jpg" alt="" >
          
        </a>
      </div>
      
      <div class="col-12 col-sm-7 text-left pl-2">
        <a href="https://huweicai.com">
          <h1 class="mb-2 h1" style="font-weight: 300;" >
            <strong>Anonymous&#39; Blog</strong>
          </h1>
        </a>
        

             
        <div class="mt-2" style="font-size: 1rem; color: white;">
            
              <a href="//github.com/Huweicai" target="_blank" rel="noopener"><i class="fab fa-github pr-1" aria-hidden="true"></i></a>    
            
            
              <a href="//linkedin.com/in/you" target="_blank" rel="noopener"><i class="fab fa-linkedin pr-1" aria-hidden="true"></i></a>
            

            
              <a href="//facebook.com/you" target="_blank" rel="noopener"><i class="fab fa-facebook pr-1" aria-hidden="true"></i></a>
            

            
            <a href="//google.com/you" target="_blank" rel="noopener"><i class="fab fa-google-plus pr-1" aria-hidden="true"></i></a>
            

            
                <a href="//twitter.com/you" target="_blank" rel="noopener"><i class="fab fa-twitter pr-1" aria-hidden="true"></i></a>
            

            
                <a href="//instagram.com/you" target="_blank" rel="noopener"><i class="fab fa-instagram pr-1" aria-hidden="true"></i></a>
            
    
            
                <a href="//px500" target="_blank" rel="noopener"><i class="fab fa-500px pr-1" aria-hidden="true"></i></a>
            
    
        
            
                <a href="mailto:i@huweicai.com"><i class="far fa-envelope-open pr-1" aria-hidden="true"></i></a>
            
    
            

            
        </div>
      </div>
    </div>
  </div>
  

  
  
  

</div>
  
    

    
  
  <main class="post-main-wrapper">
    
    
    <div class="row">

      

      
      <div class="col-md-10">
      

        
        <div class="z-depth-1  post-wrapper white-bg single-post">

          <div class="post-header text-center" >
  <ul class="post-meta li-x">
    
    
  </ul>

  <div class="px-4 post-heading">Go语言小知识</div>

  <ul class="post-meta li-x mt-1">
    
      <li>2020-08-19</li>
    

    
      <li class="middot"></li>
      <li>12 minutes read</li>
    
  </ul>
  

</div>


          <div class="post-content markdown">
            <h2 id="pool">Pool</h2>
<ul>
<li>go struct能不能比较</li>
<li>go defer 的实现原理</li>
<li>select 多个条件满足时会走哪一个分支</li>
<li>实现消息队列（多生产者，多消费者）</li>
<li>go gc 算法</li>
<li>go 协程调度模型：MPG</li>
<li>go 反射实现原理</li>
<li>sync.Pool 实现原理</li>
<li>goroutine调度用了什么系统调用</li>
<li>什么是闭包</li>
</ul>
<h3 id="for-i-遍历和-for-range-遍历有什么区别">for i 遍历和 for range 遍历有什么区别</h3>
<p>后者是前者的语法糖，编译在编译的时候还是会转化成 for i 的方式。</p>
<p>for v1,v2 := range ha 遍历数组的实际运行格式：</p>
<pre><code>ha := a
hv1 := 0
hn := len(ha)
v1 := hv1
for ; hv1 &lt; hn; hv1++ {
    tmp := ha[hv1]
    v1, v2 := hv1, tmp
    ...
}
</code></pre><p>for hv1 := range h1 遍历 channel 实际运行格式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ha</span> <span class="o">:=</span> <span class="nx">a</span>
<span class="nx">hv1</span><span class="p">,</span> <span class="nx">hb</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ha</span>
<span class="k">for</span> <span class="p">;</span> <span class="nx">hb</span> <span class="o">!=</span> <span class="kc">false</span><span class="p">;</span> <span class="nx">hv1</span><span class="p">,</span> <span class="nx">hb</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ha</span> <span class="p">{</span>
    <span class="nx">v1</span> <span class="o">:=</span> <span class="nx">hv1</span>
    <span class="nx">hv1</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>所以不难解释如下代码为什么不会永远运行了，因为这个遍历的次数一开始就根据切片的长度确定了：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">arr</span> <span class="p">{</span>
		<span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
<span class="p">}</span>

<span class="err">$</span> <span class="k">go</span> <span class="nx">run</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span>
<span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
</code></pre></div><h3 id="方法做为参数传递的时候是值传递还是引用传递">方法做为参数传递的时候是值传递还是引用传递？</h3>
<h3 id="go-map-遍历顺序是固定的吗">Go Map 遍历顺序是固定的吗</h3>
<p>不是，map 遍历并不保证遍历顺序的固定同时也不是有序的，Go 甚至会在用 for range 遍历 map 时，生成一个随机数，从随机的桶开始遍历，就是为了让大家不要依赖 map 遍历的顺序。
如果需要一个有序的 map 的话，需要自己引入其他的空间自行排序：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span>
<span class="kd">var</span> <span class="nx">keys</span> <span class="p">[]</span><span class="kt">int</span>
<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
    <span class="nx">keys</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">sort</span><span class="p">.</span><span class="nf">Ints</span><span class="p">(</span><span class="nx">keys</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">keys</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Key:&#34;</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="s">&#34;Value:&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">k</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div><h3 id="切片是如何扩容的">切片是如何扩容的</h3>
<p>参考下面这个问题。</p>
<h3 id="切片的实现原理">切片的实现原理</h3>
<p>Rob Pike 对于 slice 的定义：切片一种描述数组中的一个连续片段</p>
<p>我们在创建切片时，会先创建一个数组，然后再通过 [:] 的方式转化为切片：</p>
<pre><code>slice := []int{1, 2, 3} 

的实现原理

var vstat [3]int
vstat[0] = 1
vstat[1] = 2
vstat[2] = 3
var vauto *[3]int = new([3]int)
*vauto = vstat
slice := vauto[:]
</code></pre><p>[:]是创建切片的最底层方法，其他方式都是它的语法糖。</p>
<p>Go 语言中切片运行时是用这个结构体表示的：</p>
<pre><code>type SliceHeader struct {
   Data uintptr
   Len  int
   Cap  int
}
</code></pre><p>指向底层数组第一个元素的指针，切片的长度和容量；切片是动态的，可以通过 append 来增加元素，append 的逻辑如下，以 append 三个元素为例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// append(slice, 1, 2, 3)
</span><span class="c1"></span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="o">:=</span> <span class="nx">slice</span>
<span class="nx">newlen</span> <span class="o">:=</span> <span class="nx">len</span> <span class="o">+</span> <span class="mi">3</span>
<span class="k">if</span> <span class="nx">newlen</span> <span class="p">&gt;</span> <span class="nx">cap</span> <span class="p">{</span>
    <span class="nx">ptr</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">newlen</span><span class="p">)</span>
    <span class="nx">newlen</span> <span class="p">=</span> <span class="nx">len</span> <span class="o">+</span> <span class="mi">3</span>
<span class="p">}</span>
<span class="o">*</span><span class="p">(</span><span class="nx">ptr</span><span class="o">+</span><span class="nx">len</span><span class="p">)</span> <span class="p">=</span> <span class="mi">1</span>
<span class="o">*</span><span class="p">(</span><span class="nx">ptr</span><span class="o">+</span><span class="nx">len</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="mi">2</span>
<span class="o">*</span><span class="p">(</span><span class="nx">ptr</span><span class="o">+</span><span class="nx">len</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">=</span> <span class="mi">3</span>
<span class="k">return</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">newlen</span><span class="p">,</span> <span class="nx">cap</span><span class="p">)</span>
</code></pre></div><p>如果 cap 够用，那么会直接在底层数组上赋值并右移，所以这里会存在一个 bug：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> 
	<span class="nb">println</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="p">}</span>
<span class="nx">最终输出</span><span class="err">：</span><span class="mi">4</span>

<span class="k">go</span> <span class="nx">slice</span> <span class="nx">如果只基于</span> <span class="nx">cap</span> <span class="nx">够不够去判断要不要申请一个新数组的话</span><span class="err">，</span>
<span class="nx">第四行</span> <span class="nx">a</span> <span class="nx">的</span> <span class="nx">len</span><span class="p">=</span><span class="mi">4</span><span class="err">，</span><span class="nx">cap</span><span class="p">=</span><span class="mi">8</span><span class="err">，</span><span class="nx">看起来是容量够用的</span><span class="err">，</span><span class="nx">会直接在底层数组往后追加</span><span class="err">，</span><span class="nx">而</span> <span class="nx">b</span> <span class="nx">和</span> <span class="nx">a</span> <span class="nx">指向的是同一个底层数组</span><span class="err">，</span><span class="nx">b</span> <span class="nx">append</span> <span class="nx">的值就会被覆盖</span><span class="err">。</span>
</code></pre></div><p>当如果 cap 不够用的时候，就会触发切片的扩容机制：</p>
<p>在容量小于 1024 时，会复制成双倍，当容量大于 1024 时，会一次扩 1/4，直到可以满足需求。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">old</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span> <span class="p">{</span>
	<span class="nx">newcap</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span>
	<span class="nx">doublecap</span> <span class="o">:=</span> <span class="nx">newcap</span> <span class="o">+</span> <span class="nx">newcap</span>
	<span class="k">if</span> <span class="nx">cap</span> <span class="p">&gt;</span> <span class="nx">doublecap</span> <span class="p">{</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">1024</span> <span class="p">{</span>
			<span class="nx">newcap</span> <span class="p">=</span> <span class="nx">doublecap</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">for</span> <span class="mi">0</span> <span class="p">&lt;</span> <span class="nx">newcap</span> <span class="o">&amp;&amp;</span> <span class="nx">newcap</span> <span class="p">&lt;</span> <span class="nx">cap</span> <span class="p">{</span>
				<span class="nx">newcap</span> <span class="o">+=</span> <span class="nx">newcap</span> <span class="o">/</span> <span class="mi">4</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">newcap</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></div><p>不过再初步确定了容量之后，还有一个逻辑：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">))</span>
<span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">/</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</code></pre></div><p>会根据类型进行内存对齐，会在双倍的基础上再对容量根据最佳对齐值进行一定的向上取整。</p>
<p>切片拷贝时会调用：memmove，将整块内存空间全部复制到新的地方，同时把源切片的 Len 复制给新的切片，而不是一个一个元素在 Go 代码层面的复制。</p>
<h3 id="空切片和-nil-有什么区别-a--int-a--nil">空切片和 nil 有什么区别： a := []int{} a := nil</h3>
<p>我们可以通过 <code>*(*reflect.SliceHeader)(unsafe.Pointer(&amp;slice))</code>显示的将切片转化为其底层数据结构，便于分析：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">c</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">aHeader</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">SliceHeader</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">))</span>
	<span class="nx">bHeader</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">SliceHeader</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">))</span>
	<span class="nx">cHeader</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">SliceHeader</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">aHeader</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">bHeader</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">cHeader</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">输出</span><span class="err">：</span>
<span class="p">{</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">}</span>
<span class="p">{</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">}</span>
<span class="p">{</span><span class="mi">824634355400</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">}</span>
</code></pre></div><p>我们分别用申明变量、显示赋值为 nil、初始化一个空切片的方式构造了三个切片，转化为底层数据结构在打印日志可以发现，前两种方式指向数组的指针其实并没有初始化，而第三种方式 Data 会指向一个数组，虽然它的长度为0。</p>
<p>这个不同会导致前两者在 json 序列化的时候被序列化成：<code>null</code>，而空切片则会序列化为：<code>[]</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">c</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">aBytes</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">bBytes</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="nx">cBytes</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="nb">println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">aBytes</span><span class="p">))</span>
	<span class="nb">println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">bBytes</span><span class="p">))</span>
	<span class="nb">println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">cBytes</span><span class="p">))</span>
<span class="p">}</span>

<span class="nx">输出</span><span class="err">：</span>
<span class="nx">null</span>
<span class="nx">null</span>
<span class="p">[]</span>
</code></pre></div><h3 id="go-字符串实现原理">Go 字符串实现原理</h3>
<p>字符串的实现其实和切片比较像，只是没有容量而已：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StringHeader</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Data</span> <span class="kt">uintptr</span>
	<span class="nx">Len</span>  <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><p>字符串的底层是一个只读的字节数组：[]byte，所以其实也不用担心字符串在传递时的性能开销。</p>
<p>因为 string 是只读的，而字节数组是可以修改的，所以在和 []byte 相互转换时会通过：memmove 复制内存，所以我们最好尽量避免这两者之间的频繁转换。</p>
<p>Go 里的字符串是使用 UTF-8 编码的，相较于 Unicode，英文字符等跟 ASCII 一样只要占用一个字节，中文字符在 ASCII 下基本都要占用三个字节，在使用 for range 遍历 string 时，是按照字符而不是字节去遍历，值也是用 rune 类型承接的，不过每次的序号还是这个字符的第一个字节的下标。</p>
<p>我们在需要字符的序号时，可以把字符串转成 []rune 数组去遍历。</p>
<p>同时我们也可以转成 []byte 强制其按字节遍历。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">str</span> <span class="o">:=</span> <span class="s">&#34;你好啊今天天气真不错&#34;</span>
	<span class="nx">runeTotal</span><span class="p">,</span> <span class="nx">byteTotal</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="k">range</span> <span class="nx">str</span> <span class="p">{</span>
		<span class="nx">runeTotal</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="k">range</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">byteTotal</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;字符数：%d 字节数：%d 长度：%d&#34;</span><span class="p">,</span> <span class="nx">runeTotal</span><span class="p">,</span> <span class="nx">byteTotal</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">))</span>
<span class="p">}</span>

<span class="nx">输出</span><span class="err">：</span><span class="nx">字符数</span><span class="err">：</span><span class="mi">10</span> <span class="nx">字节数</span><span class="err">：</span><span class="mi">30</span> <span class="nx">长度</span><span class="err">：</span><span class="mi">30</span>
</code></pre></div><h3 id="长度不同的数组是同样的类型吗">长度不同的数组是同样的类型吗？</h3>
<p>不是；[2]int 和 [3]int 并不是一个类型，<code>reflect.TypeOf([3]int{}).String()</code> 的结果是：[3]int，长度也是数组的一个元信息。</p>
<p>但它们的 Kind 是一样的，都是：array。</p>
<h3 id="go-为什么使用-plan9-作为汇编语言">Go 为什么使用 Plan9 作为汇编语言？</h3>
<p>因为 Go 的作者大部分以前都是搞 Plan9 的，他们在 Go 里重新启用了这种类似的汇编语法，微跨平台汇编语法，所有指令集通用的 ADD MOV JUMP PUSH 之类的指令在 Plan9 里相当于有了一个统一的指令名称，有的指令实在是只在某个指令集上有，那就没办法了，只能说能省一点力气是一点力气。</p>
<p>编译为 Plan9 汇编之后，Go 实现了一个比较轻量的汇编器来真正将 Plan9 翻译成对应平台的机器码。</p>
<p><a href="https://9p.io/sys/doc/asm.html">https://9p.io/sys/doc/asm.html</a></p>
<h3 id="interface-之-eface-的实现">interface{} 之 eface 的实现</h3>
<p>go 里的接口有两种，带方法的接口：iface，和不带方法的 eface，我们平常在处理任意类型时所用的参数类型，就是一种特殊的接口 interface{}，这个接口没有方法，所以所有的结构体都实现了它，由于 go 的接口是 duck type 的，所以任何结构体都可以传递到以 interface{} 为参数的方法中，这种传值方式跟：io.Reader 这种接口其实是一个性质。空的接口在 go 中做了特殊处理，interface{} 就是 eface，eface 包括一个类型指针和一个指向真实数据的指针。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">eface</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// 16 bytes
</span><span class="c1"></span>	<span class="nx">_type</span> <span class="o">*</span><span class="nx">_type</span>
	<span class="nx">data</span>  <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>
</code></pre></div><h3 id="go-反射的实现原理">Go 反射的实现原理</h3>
<p><a href="">Go 反射的的三大定律</a></p>
<p>反射的入口主要是两个方法：reflect.TypeOf 和 reflect.ValueOf，对应的它们的入参都是一个 interface{}，interface{} 内部会有两个变量，一个是 type，一个是指向原始数据的指针，而反射的两个方法就是分别获取的对应的这两个值。</p>
<p>reflect.TypeOf:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TypeOf</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Type</span> <span class="p">{</span>
	<span class="nx">eface</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">emptyInterface</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">))</span>
	<span class="k">return</span> <span class="nf">toType</span><span class="p">(</span><span class="nx">eface</span><span class="p">.</span><span class="nx">typ</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>reflect.reflect.ValueOf:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ValueOf</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Value</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptyInterface</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">))</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">typ</span>
	<span class="nx">f</span> <span class="o">:=</span> <span class="nf">flag</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Kind</span><span class="p">())</span>
	<span class="k">if</span> <span class="nf">ifaceIndir</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">f</span> <span class="o">|=</span> <span class="nx">flagIndir</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">Value</span><span class="p">{</span><span class="nx">t</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">word</span><span class="p">,</span> <span class="nx">f</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="go-常见性能优化点">Go 常见性能优化点</h3>
<h4 id="找到瓶颈点">找到瓶颈点</h4>
<ul>
<li>go tool pprof 分析内存</li>
<li>go tool trace 协程运行分析</li>
<li>go build -gcflags=&rdquo;-m&rdquo; 查看逃逸分析，编译器优化</li>
</ul>
<h4 id="优化-gc">优化 GC</h4>
<ul>
<li>map 存值而不是指针，指针会影响 gc 标记时长</li>
</ul>
<h4 id="减少内存拷贝">减少内存拷贝</h4>
<ul>
<li>大对象使用指针而不是值类型，减少方法传递时带来的性能损耗</li>
<li>尽量避免在 []byte 和 string 两种类型之间频繁转换，每一次都要完整拷贝内存，性能影响很大</li>
<li>使用 strings.Builder 而不是 butes.buffer 甚至是加号来拼接字符串，性能从左到右依次递减，bytes.buffer 底层是一个byte数组，最后会通过 string([]byte) 转成 string，会发生一次内存拷贝，而用加号拼接，每拼接一次都会申请一块新的内存，性能更差</li>
<li>使用切片时尽量预分配长度，无法确定长度也可以先尽量预分配容量，减少切片扩容带来的内存拷贝</li>
</ul>
<h4 id="减少内存分配">减少内存分配</h4>
<ul>
<li>小对象使用值类型而不是指针，指针会导致逃逸分析失效，对象分配在堆上，对于小对象而言得不偿失</li>
<li>使用空 struct{} 来进行占位，不需要分配内存，编译器会将空 struct{} 全部指向 runtime.zerobase</li>
<li>合理复用对象，或者使用对象池：sync.Pool，减少内存分配，同时降低 GC <a href="">压力</a></li>
</ul>
<h4 id="并发优化">并发优化</h4>
<ul>
<li>使用 atomic.CAS atomic.Add 在单次操作上替代 sync.Mutex，前者只是一个 CPU 指令，而后者则是负责的软件逻辑</li>
</ul>
<h3 id="判断如下代码返回的结果">判断如下代码返回的结果</h3>
<pre><code>func main() {
   println(ErrorA() == nil)
   println(ErrorB() == nil)
}

func ErrorA() error {
   return nil
}

func ErrorB() error {
   var err *os.PathError
   return err
}
</code></pre><p>返回的结果会是：true，false。</p>
<p>因为 Go 里面 interface 由两个元素组成，Type 和 Value，Type 表示对象的具体类型，Value 指向对应的内存地址，只有当 Type 和 Value 都为空时，interface 才为空。</p>
<p>而函数 B 中将 err 变量转换为了 error interface 返回的，而它的 Type 为 *os.PathError 不为空，所以判断是否为 nil 会返回否定的结果。</p>
<p>而在方法 A 中，虽然 nil 也被转换成了 interface，但是它的 Type 就是 nil，所以能走到正常的逻辑。</p>
<p>这也是为什么当代码中没有错误时推荐显示返回 nil 而不是空指针的原因了。</p>
<h3 id="select-实现超时逻辑">select 实现超时逻辑</h3>
<p>time.After 会在指定时间之后在返回的管道中发送当前时间，这样循环就会退出。</p>
<p>time.After 封装了一下 timer.Timer，在计时结束之后就 Timer 对象就会被垃圾回收。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span>
  	<span class="k">break</span><span class="p">;</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// do something
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="go-map实现原理">Go Map实现原理</h3>
<p>Go map 的底层数据结构是一个 hmap 结构体，定义于 runtime/map.go 文件中：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
</span><span class="c1"></span>	<span class="c1">// Make sure this stays in sync with the compiler&#39;s definition.
</span><span class="c1"></span>  <span class="nx">count</span>     <span class="kt">int</span> <span class="c1">// 数量，len() 返回的结果
</span><span class="c1"></span>	<span class="nx">flags</span>     <span class="kt">uint8</span>
	<span class="nx">B</span>         <span class="kt">uint8</span>  <span class="c1">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)
</span><span class="c1"></span>	<span class="nx">noverflow</span> <span class="kt">uint16</span> <span class="c1">// approximate number of overflow buckets; see incrnoverflow for details
</span><span class="c1"></span>	<span class="nx">hash0</span>     <span class="kt">uint32</span> <span class="c1">// hash seed
</span><span class="c1"></span>
	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// array of 2^B Buckets. may be nil if count==0.
</span><span class="c1"></span>	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// previous bucket array of half the size, non-nil only when growing
</span><span class="c1"></span>	<span class="nx">nevacuate</span>  <span class="kt">uintptr</span>        <span class="c1">// progress counter for evacuation (buckets less than this have been evacuated)
</span><span class="c1"></span>
	<span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span> <span class="c1">// optional fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="go-变量初始化的执行顺序">Go 变量初始化的执行顺序</h3>
<p><img src="https://cdn.jsdelivr.net/gh/Huweicai/images/20200902154225.png" alt="这里写图片描述"></p>
<p>main 函数是系统的入口，从 main 函数所在的包开始初始化：</p>
<p>**包之间：**一个包在初始化之前，会按照引入顺序先初始化其所依赖的的包，一直递归下去；</p>
<p>**包内：**一个包内不同的文件之间会按照文件名字符顺序初始化：a.go &gt; b.go</p>
<p>**文件内：**初始化按照字段类型顺序为：常量 -&gt; 变量 -&gt; init 函数</p>
<p>**一种字段类型内：**按照申明顺序从上到下初始化</p>
<h3 id="syncmutex-锁实现原理">sync.Mutex 锁实现原理</h3>
<p>sync.Mutext 是 go 提供的一种同步原语，用于表达互斥，不过不推荐在业务中使用，应首通过沟通（管道+协程）来共享内存，而不是通过共享内存来沟通。</p>
<p>Mutex 结构体如下，只有两个变量，非常简单：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">state</span> <span class="kt">int32</span>
   <span class="nx">sema</span>  <span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></div><p>state 字段是一个位图</p>
<ul>
<li>第 0 位表示是否加锁</li>
<li>第 1 位表示是否已唤醒</li>
<li>第 2 位表示是否为饥饿模式</li>
<li>剩下的位则用于表示在这个 Mutex 上等待的 goroutine 数量</li>
</ul>
<p>sema 是一个信号量，配合 sleep 原语和 notify 原因使用，具体实现是协程调用 runtime_SemacquireMutex 用于在信号量上等待信号量大于0，runtime_Semrelease 则会唤醒在这个信号量上等待的协程。</p>
<p>加锁的时候其实就是尝试将state的第一个位置成true，表示已经加锁，而解锁则是将其置回0再调用runtime_Semrelease唤醒等待的协程。</p>
<p>不过之后的版本引入了饥饿模式，当有协程等待超过一毫秒之后，就会进入饥饿模式，所有占用CPU的协程不再尝试自旋获取锁，直接去等待队列尾端排队，锁会在释放后直接递交给等待队列中的第一个协程。当满足以下任一条件时就会退出饥饿模式：</p>
<ul>
<li>等待时间小于 1ms</li>
<li>等待队列空了</li>
</ul>
<p>不过需要注意的是，go 的 Mutex 并没有额外去实现可重入的机制，所以当一个获取了锁再尝试去加锁时就会死锁。</p>
<p>在 Java 里面有重量级锁和轻量级锁的概念，在 go 里面对应的则是在信号量上等待的饥饿模式和自旋空等的普通模式。</p>
<p>而饥饿模式和普通模式的切换，则也是 go 在公平和性能中的一个权衡。</p>
<h3 id="syncrwmutex-读写锁实现原理">sync.RWMutex 读写锁实现原理</h3>
<p>RWMutex 提供的是一个读写锁的功能，同一时间可以有很多个读者在读，或者一个写者在写，适用于读多写少的场景；</p>
<p>RWMutex 的实现和 Mutex 一样，也是基于信号量和atomic指令来实现的；</p>
<p>数据结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RWMutex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">w</span>           <span class="nx">Mutex</span>  <span class="c1">// 写者锁
</span><span class="c1"></span>	<span class="nx">writerSem</span>   <span class="kt">uint32</span> <span class="c1">// 写者信号量
</span><span class="c1"></span>	<span class="nx">readerSem</span>   <span class="kt">uint32</span> <span class="c1">// 读者信号量
</span><span class="c1"></span>	<span class="nx">readerCount</span> <span class="kt">int32</span>  <span class="c1">// 读者数量
</span><span class="c1"></span>	<span class="nx">readerWait</span>  <span class="kt">int32</span>  <span class="c1">// 离开的写者数量
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">const</span> <span class="nx">rwmutexMaxReaders</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span> <span class="c1">// 最大的读者数量，2^30 = 1073741824
</span></code></pre></div><p>大致的实现原理就是，读加锁时会先把读者数量加一，然后判断当前有没有协程尝试写入，没有的话就可以读了，如果有的话那么就会挂起，挂起是通过判断读者数量是否为负数来实现的，所以这里会限制读者数量不能超过rwmutexMaxReaders，这样才能保证读者数量能在尝试写入时一定能变成负值；在尝试加写锁时会先通过 Mutex 跟其他尝试写的协程竞争，然后才能进入临界区，进入之后就会把读者数量减去rwmutexMaxReaders变成负数，这样就不会有新增的读者，然后等待当前正在读的读者全部读完，最后一个读者读完之后会唤醒它，然后就可以开始写了，写者写完之后唤醒读者，大家你来我往，井井有条。</p>
<h3 id="synccond条件变量">sync.Cond条件变量</h3>
<p>Cond 是一个条件变量：</p>
<ul>
<li>Wait 等待</li>
<li>Notify 唤醒一个等待的协程</li>
<li>BroadCast 唤醒所有等待的协程</li>
</ul>
<p>不过这个库在 Go 显得有的有点鸡肋，管道既可以实现信号量的功能，而且还顺带可以传输数据，具体实现的话底层和锁依赖的信号量一样的。</p>
<h3 id="syncwaitgroup-等待条件">sync.WaitGroup 等待条件</h3>
<p>waitGroup 类似于 Java 里面的 CountDownLatch类，可以让一个协程等待其他协程任务的完成，拥有三个方法：</p>
<ul>
<li>Add 申明要等待的数量</li>
<li>Done 完成了一个任务，Add( -1)</li>
<li>Wait 等待</li>
</ul>
<p>底层实现也是通过 atomic 和信号量来实现的。</p>
<p>一个没有 WaitGroup 的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">wg</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="nx">size</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">size</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
			<span class="nx">wg</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">size</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="o">&lt;-</span><span class="nx">wg</span>
	<span class="p">}</span>
</code></pre></div><p>WaitGroup 版本：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="nx">size</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">size</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</code></pre></div><h3 id="synconce-实现原理">sync.Once 实现原理</h3>
<p>sync.Once 数据结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Once</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">done</span> <span class="kt">uint32</span>
	<span class="nx">m</span>    <span class="nx">Mutex</span>
<span class="p">}</span>
</code></pre></div><p>sync.Once 可以保证提交给它的方法无论被调用多少次也只会执行一次，这个其实就是一个经典的单例模式的解决方案，两步判断，实现原理如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 判断是否已经被执行过
</span><span class="c1"></span>		<span class="k">return</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>	<span class="c1">// 加锁尝试初始化
</span><span class="c1"></span><span class="k">defer</span> <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">done</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// 在等待锁的时候已经被其他协程执行过了
</span><span class="c1"></span>	<span class="k">return</span>
<span class="p">}</span>
 
<span class="nf">f</span><span class="p">()</span> <span class="c1">// 执行
</span><span class="c1"></span><span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 标记已完成
</span></code></pre></div><h3 id="syncmap-实现原理">sync.Map 实现原理</h3>
<p>Go 语言中自带的 map 出于性能考虑并不是线程安全的，go 1.9 加入了 sync.Map 来提供并发场景下哈希表的高性能解决方案，数据结构如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">mu</span> <span class="nx">Mutex</span>
  	<span class="nx">read</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span> <span class="c1">// 只读数据
</span><span class="c1"></span>  	<span class="nx">dirty</span> <span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="o">*</span><span class="nx">entry</span> <span class="c1">// 动态数据
</span><span class="c1"></span>  	<span class="nx">misses</span> <span class="kt">int</span>	<span class="c1">// 未命中的数量
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// read 的结构
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">readOnly</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">m</span>       <span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="o">*</span><span class="nx">entry</span>
	<span class="nx">amended</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div><p>读取数据时会先从 read 中读取，read 中读不到才会尝试去 dirty 读，任何对 dirty 的操作都会加锁，来保证数据的安全。</p>
<p>修改数据时会尝试 CAS 直接修改 read，因为 read 和 dirty 指向的数据：entry 其实是同一份，所以修改是会生效的。</p>
<p>添加数据时则会直接添加到 dirty 中，数据添加后虽然没有在 read 里出现，但是还是会穿透查到 dirty 中来，但穿透次数频繁到一定程度后，就会把 dirty 升级为 read。</p>
<p>因为 read 是只读的，所以不能直接删除，sync.Map 替换掉原有数据指向一个特殊的标记来表示数据已经被删除，同时会在 dirty 中删除这个 key，这样这个 key 就不会一直存在。</p>
<p>sync.Map 的思想是用空间换时间，维护了一个只读的数据副本，对于读多写少的场景性能几乎和普通 map 一样，但是当写入和删除频繁时性能就比较差了，不过还是比用全局读写锁保护的map要好很多。</p>
<p>Java 里面的 ConcurrentHashMap 的思路则是锁粒度细分，不过 Go 社区里面也有用这种思路实现的开源库：https://github.com/orcaman/concurrent-map。</p>
<h4 id="go-timer-实现原理">go Timer 实现原理</h4>
<p>首先如果让我们自己去实现一个 Timer 的话，我们可以计算出来要具体下一次调度的时间，然后 sleep 对应的时长就好了，但是如果创建了很多的 Timer 的话，这样的性能其实是比较差的，go 里面会有一个协程统一负责管理 timer 来执行我们上面这个操作，所有的 timer 会放在一个堆中进行管理，每次取堆顶的值来判断要 sleep 多久即可。</p>
<h3 id="两个协程交替打印从1到100的数字">两个协程交替打印从1到100的数字</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">goal</span> <span class="o">:=</span> <span class="mi">100</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="c1">// 启动信号
</span><span class="c1"></span>
	<span class="nx">run</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">id</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="nx">id</span> <span class="o">+</span> <span class="s">&#34;: &#34;</span><span class="p">)</span>
			<span class="nb">println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">goal</span> <span class="p">{</span>
				<span class="nx">done</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
				<span class="k">return</span>
			<span class="p">}</span>

			<span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">go</span> <span class="nf">run</span><span class="p">(</span><span class="s">&#34;1&#34;</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">run</span><span class="p">(</span><span class="s">&#34;2&#34;</span><span class="p">)</span>

	<span class="o">&lt;-</span><span class="nx">done</span>
<span class="p">}</span>
</code></pre></div>
          </div>

          
          <div class="row">
            <div class="col-md-8">
            
            </div>
            
          </div>
          

          
          <div class="row pt-3">
            <div class="col-md-6">
              
                <a href=https://huweicai.com/personal/mysql-create-options/ class="post-meta">Previous
                  <div class="pt-2 pb-5 d-flex">
                    <i class="fas fa-angle-left text-grey font-weight-bold mr-2 active-color"></i>
                    <span>MySQL建表选项</span>
                  </div>
                </a>
              
            </div>
            
            <div class="col-md-6 text-right" >
              
            </div>
          </div>

          

        </div>
        

      </div>
      

      
	
	
	
	
		
		
		
	

		
		<div class="col-md-2 pl-0">

			
			<div id="page-scrollspy" class="toc-nav">
				
				<ul class="nav nav-pills ml-0">
					
					<li class="nav-item pb-3 text-center">
						<span class="font-weight-bold mb-2">- CATALOG - </span>
					</li>

					
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#pool">
												 Pool
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#for-i-%e9%81%8d%e5%8e%86%e5%92%8c-for-range-%e9%81%8d%e5%8e%86%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab">
												 for i 遍历和 for range 遍历有什么区别
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e6%96%b9%e6%b3%95%e5%81%9a%e4%b8%ba%e5%8f%82%e6%95%b0%e4%bc%a0%e9%80%92%e7%9a%84%e6%97%b6%e5%80%99%e6%98%af%e5%80%bc%e4%bc%a0%e9%80%92%e8%bf%98%e6%98%af%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92">
												 方法做为参数传递的时候是值传递还是引用传递？
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#go-map-%e9%81%8d%e5%8e%86%e9%a1%ba%e5%ba%8f%e6%98%af%e5%9b%ba%e5%ae%9a%e7%9a%84%e5%90%97">
												 Go Map 遍历顺序是固定的吗
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%88%87%e7%89%87%e6%98%af%e5%a6%82%e4%bd%95%e6%89%a9%e5%ae%b9%e7%9a%84">
												 切片是如何扩容的
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%88%87%e7%89%87%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">
												 切片的实现原理
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e7%a9%ba%e5%88%87%e7%89%87%e5%92%8c-nil-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab-a--int-a--nil">
												 空切片和 nil 有什么区别： a := []int{} a := nil
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#go-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">
												 Go 字符串实现原理
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e9%95%bf%e5%ba%a6%e4%b8%8d%e5%90%8c%e7%9a%84%e6%95%b0%e7%bb%84%e6%98%af%e5%90%8c%e6%a0%b7%e7%9a%84%e7%b1%bb%e5%9e%8b%e5%90%97">
												 长度不同的数组是同样的类型吗？
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#go-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8-plan9-%e4%bd%9c%e4%b8%ba%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80">
												 Go 为什么使用 Plan9 作为汇编语言？
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#interface-%e4%b9%8b-eface-%e7%9a%84%e5%ae%9e%e7%8e%b0">
												 interface{} 之 eface 的实现
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#go-%e5%8f%8d%e5%b0%84%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">
												 Go 反射的实现原理
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#go-%e5%b8%b8%e8%a7%81%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e7%82%b9">
												 Go 常见性能优化点
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e6%89%be%e5%88%b0%e7%93%b6%e9%a2%88%e7%82%b9">
												 找到瓶颈点
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e4%bc%98%e5%8c%96-gc">
												 优化 GC
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%87%8f%e5%b0%91%e5%86%85%e5%ad%98%e6%8b%b7%e8%b4%9d">
												 减少内存拷贝
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%87%8f%e5%b0%91%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d">
												 减少内存分配
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%b9%b6%e5%8f%91%e4%bc%98%e5%8c%96">
												 并发优化
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e5%88%a4%e6%96%ad%e5%a6%82%e4%b8%8b%e4%bb%a3%e7%a0%81%e8%bf%94%e5%9b%9e%e7%9a%84%e7%bb%93%e6%9e%9c">
												 判断如下代码返回的结果
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#select-%e5%ae%9e%e7%8e%b0%e8%b6%85%e6%97%b6%e9%80%bb%e8%be%91">
												 select 实现超时逻辑
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#go-map%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">
												 Go Map实现原理
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#go-%e5%8f%98%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96%e7%9a%84%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f">
												 Go 变量初始化的执行顺序
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#syncmutex-%e9%94%81%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">
												 sync.Mutex 锁实现原理
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#syncrwmutex-%e8%af%bb%e5%86%99%e9%94%81%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">
												 sync.RWMutex 读写锁实现原理
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#synccond%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f">
												 sync.Cond条件变量
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#syncwaitgroup-%e7%ad%89%e5%be%85%e6%9d%a1%e4%bb%b6">
												 sync.WaitGroup 等待条件
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#synconce-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">
												 sync.Once 实现原理
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#syncmap-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">
												 sync.Map 实现原理
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#go-timer-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">
												 go Timer 实现原理
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#%e4%b8%a4%e4%b8%aa%e5%8d%8f%e7%a8%8b%e4%ba%a4%e6%9b%bf%e6%89%93%e5%8d%b0%e4%bb%8e1%e5%88%b0100%e7%9a%84%e6%95%b0%e5%ad%97">
												 两个协程交替打印从1到100的数字
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 

				</ul>
			</div>
			

		</div>
		
	

    </div>
    


  </main>
  


    
    

<footer class="page-footer text-center font-small mt-4 wow fadeIn">


  
  <div class="pb-2 mt-5 pt-5">
    
      <a href="//github.com/Huweicai " target="_blank" rel="noopener"><i class="fab fa-github mr-3" aria-hidden="true"></i></a>    
    
    
      <a href="//linkedin.com/in/you" target="_blank" rel="noopener"><i class="fab fa-linkedin-in mr-3" aria-hidden="true"></i></a>
    

    
      <a href="//facebook.com/you" target="_blank" rel="noopener"><i class="fab fa-facebook-f mr-3" aria-hidden="true"></i></a>
    

    
    <a href="//google.com/you" target="_blank" rel="noopener"><i class="fab fa-google-plus-g mr-3" aria-hidden="true"></i></a>
    

    
        <a href="//twitter.com/you" target="_blank" rel="noopener"><i class="fab fa-twitter mr-3" aria-hidden="true"></i></a>
    

    
        <a href="//instagram.com/you" target="_blank" rel="noopener"><i class="fab fa-instagram mr-3" aria-hidden="true"></i></a>
    

    
        <a href="//px500" target="_blank" rel="noopener"><i class="fab fa-500px mr-3" aria-hidden="true"></i></a>
    


    
        <a href="mailto:i@huweicai.com"><i class="far fa-envelope-open mr-3" aria-hidden="true"></i></a>
    

    

    

  </div>
  

  
  <div class="copyright py-4">
    
    <span>  2016 - 2020 &copy; | Theme <a href='https://github.com/orianna-zzo/AllinOne' target="_blank">AllinOne</a> by <a href='https://github.com/orianna-zzo' target="_blank">Orianna</a>  </span>
  </div>
  

</footer>


    






<script type="text/javascript" src="https://huweicai.com/js/vendors/jquery/jquery-3.3.1.min.js"></script>
<script type="text/javascript" src="https://huweicai.com/js/vendors/jquery/jquery.smooth-scroll.min.js"></script>



<script type="text/javascript" src="https://huweicai.com/js/vendors/popper.min.js"></script>
<script type="text/javascript" src="https://huweicai.com/js/vendors/holder.min.js"></script>
<script type="text/javascript" src="https://huweicai.com/js/vendors-extensions/bootstrap4/bootstrap.js" ></script>

<script type="text/javascript" src="https://huweicai.com/js/vendors/mdb/mdb.min.js"></script>

<script type="text/javascript" src="https://huweicai.com/js/main.js"></script>



  
  <script src="https://huweicai.com/js/vendors/highlight.pack.js"> </script>
  <script>hljs.initHighlightingOnLoad();</script>




 
  <script src="https://huweicai.com/js/vendors/katex/katex.min.js"> </script>
  <script src="https://huweicai.com/js/vendors/katex/contrib/auto-render.min.js"></script>

  <script>
      document.addEventListener("DOMContentLoaded", function () {
          renderMathInElement(document.body);
      });
  </script>








<script type="text/javascript">
  
  new WOW().init();
</script>




  </body>
</html>