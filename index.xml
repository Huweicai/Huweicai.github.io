<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Anonymous&#39; Blog</title>
    <link>https://huweicai.com/</link>
    <description>Recent content on Anonymous&#39; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Fri, 29 May 2020 19:58:00 +0800</lastBuildDate>
    
	<atom:link href="https://huweicai.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang 如何排查协程泄漏问题</title>
      <link>https://huweicai.com/blog/2020-05/golang-%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%8D%8F%E7%A8%8B%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 29 May 2020 19:58:00 +0800</pubDate>
      
      <guid>https://huweicai.com/blog/2020-05/golang-%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%8D%8F%E7%A8%8B%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/</guid>
      <description>背景 周所周知，内存泄漏是一个很严重的问题，会导致系统运行占用资源越来越多，无法释放，直至崩溃。所幸 Go 语言是一门 具有垃圾回收的语言，能大大降低遇到内存泄漏的概率，而我们今天要说的是另外一个棘手的问题：协程泄漏。 协程泄漏：顾名思义就是出现了应该释放而没有被释放的协程，导致系统协程数量一直上升。不像对象回收需要引用计数、三色标记等手段，协程的回收是相当简单的，等待协程将代码从头到尾执行完毕之后这一块儿空</description>
    </item>
    
    <item>
      <title>颜色是如何呈现的</title>
      <link>https://huweicai.com/blog/2020-04/%E9%A2%9C%E8%89%B2%E6%98%AF%E5%A6%82%E4%BD%95%E5%91%88%E7%8E%B0%E7%9A%84/</link>
      <pubDate>Thu, 09 Apr 2020 01:27:11 +0800</pubDate>
      
      <guid>https://huweicai.com/blog/2020-04/%E9%A2%9C%E8%89%B2%E6%98%AF%E5%A6%82%E4%BD%95%E5%91%88%E7%8E%B0%E7%9A%84/</guid>
      <description>现实的世界是丰富多彩的，然而我们又是怎么将这种色彩呈现到我们的显示器上的呢？ 人眼如何感知色彩 众所周知，光是一种电磁波，可见光是人眼所能处理的一个电磁波频率区间子集，人眼看到事物是通过光来感知的，颜色的本质就是电磁波的频率，不同频率的光即我们语言中所定义的不同种类的颜色。本质上我们的眼睛和雷达并没有任何区别，只是大脑的解码渲染能力强一点罢了。 人的眼睛中有视锥细胞和视杆细胞，视杆细胞负责感受光的强度，</description>
    </item>
    
    <item>
      <title>Redis FAQ</title>
      <link>https://huweicai.com/blog/2020-01/redis-faq/</link>
      <pubDate>Sat, 04 Jan 2020 22:43:00 +0800</pubDate>
      
      <guid>https://huweicai.com/blog/2020-01/redis-faq/</guid>
      <description>简单翻译Redis官网的FAQ以及部分自己总结的问题 官网FAQ地址 Redos持久化策略：RDB和AOF RDB：数据快照，数据整体快照，吞吐量较大，但单次耗时较长，如果在dump的时候宕机可能会导致数据丢失。 AOF：日志追加，占空间比RDB大，但安全性更好，每秒追加一次日志，丢失数据的可能性会小很多，但是宕机恢复很慢。 而在实际生产环境中，我们通常会将两种持久化策略共同使用，定期进行数据快照，同时保留</description>
    </item>
    
    <item>
      <title>Golang 多路条件语句 Switch 语法详解&#34;</title>
      <link>https://huweicai.com/blog/2020-01/golang-%E5%A4%9A%E8%B7%AF%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-switch-%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 02 Jan 2020 12:09:00 +0800</pubDate>
      
      <guid>https://huweicai.com/blog/2020-01/golang-%E5%A4%9A%E8%B7%AF%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-switch-%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/</guid>
      <description>Switch 是 Go 语言中一种多路条件语句，一般搭配 case 语句使用。 执行逻辑 一个 switch case 条件结构如下所示： switch simpleStatement; condition { case expression1,expression2: statements case expression3: statements default: statements } 和 if 语句类似，switch 语句也可以在条件语句之前执行一段简短的表达式（可以用于很方便的控制变量的作用域），switch case 开始执行时，会先执行这一个表达式（空也算一种），然后计算出条件语句的值，接着按从上到下，从左到右的顺序一个一个的执行 case 语句的条件表达式，如果值相等的话就会进入执行 case 条件</description>
    </item>
    
    <item>
      <title>在线 Markdown 转 PDF 工具评测</title>
      <link>https://huweicai.com/blog/2019-07/%E5%9C%A8%E7%BA%BF-markdown-%E8%BD%AC-pdf-%E5%B7%A5%E5%85%B7%E8%AF%84%E6%B5%8B/</link>
      <pubDate>Tue, 02 Jul 2019 08:47:11 +0800</pubDate>
      
      <guid>https://huweicai.com/blog/2019-07/%E5%9C%A8%E7%BA%BF-markdown-%E8%BD%AC-pdf-%E5%B7%A5%E5%85%B7%E8%AF%84%E6%B5%8B/</guid>
      <description>用 Markdown 写了这么久博客，对于这种简约风格还是非常喜欢的，所以在写一些其他文档的时候我也更倾向于这种格式。最近需要写一些 PDF 格式的文档，所以我找了一些在线 Markdown 转 PDF 的网站，不同的网站渲染出来的风格并不一样，我在下面做了一个对比，帮助大家进行选择。 测试数据 # 测试测试 1111111111 / 测试 / 123 Email: test@test.com Test: test Website: https://github.com.cn * * * 123213123 测出测试 真的测试 测试吧 * * * # 二阶段测试 - 真的测试测试 - 真的测试测试/真的测试测试 - 微博：[@Easy](http:</description>
    </item>
    
    <item>
      <title>Java跨平台究竟能跨哪些平台</title>
      <link>https://huweicai.com/blog/2019-05/java%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%A9%B6%E7%AB%9F%E8%83%BD%E8%B7%A8%E5%93%AA%E4%BA%9B%E5%B9%B3%E5%8F%B0/</link>
      <pubDate>Mon, 20 May 2019 23:47:00 +0800</pubDate>
      
      <guid>https://huweicai.com/blog/2019-05/java%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%A9%B6%E7%AB%9F%E8%83%BD%E8%B7%A8%E5%93%AA%E4%BA%9B%E5%B9%B3%E5%8F%B0/</guid>
      <description>众所周知，Java跨平台的一直被众多Java程序员们津津乐道，“一次编写，到处运行”的设想着实令人心动，虽然会带来一定性能上的问题，但这并不妨碍大家对Java的喜爱，既然都说Java能跨平台，Java 也并不是凭空就能跑在任何机器上，这是不现实的，需要官方针对对应的平台，编译一套对应平台包括 Java 虚拟机（Java Runtime Environment 简称 JRE）在内的 Java 开发工具集（Java Develop Kit，简称 JDK），这样我们编写的 Java 代码才算</description>
    </item>
    
    <item>
      <title>小论计算机Encoding</title>
      <link>https://huweicai.com/blog/2018-05/%E5%B0%8F%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BAencoding/</link>
      <pubDate>Sat, 26 May 2018 12:47:11 +0800</pubDate>
      
      <guid>https://huweicai.com/blog/2018-05/%E5%B0%8F%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BAencoding/</guid>
      <description>乱码问题一直是最让人心烦的一类问题，因为不知从何而来，由何而起，只能一处一处的改编码，运气好了就改成功了，运气不好就继续试，有时候明明把所有能改的地方全改成UTF-8了，却仍然无济于事，着实叫人抓狂。这一切都要从1946年的那个春天说起。 在第一计算机台诞生的时候，那个时候还只有0和1，慢慢的，科学家们厌倦了只有0和1的世界，所以他们就聚在一起开了个会，讨论了讨论，决定按特定的方式将人类语言映射到0</description>
    </item>
    
    <item>
      <title>小论计算机Encoding</title>
      <link>https://huweicai.com/%E5%B0%8F%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BAencoding/</link>
      <pubDate>Sat, 26 May 2018 12:47:11 +0800</pubDate>
      
      <guid>https://huweicai.com/%E5%B0%8F%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BAencoding/</guid>
      <description>乱码问题一直是最让人心烦的一类问题，因为不知从何而来，由何而起，只能一处一处的改编码，运气好了就改成功了，运气不好就继续试，有时候明明把所有能改的地方全改成UTF-8了，却仍然无济于事，着实叫人抓狂。这一切都要从1946年的那个春天说起。 在第一计算机台诞生的时候，那个时候还只有0和1，慢慢的，科学家们厌倦了只有0和1的世界，所以他们就聚在一起开了个会，讨论了讨论，决定按特定的方式将人类语言映射到0</description>
    </item>
    
    <item>
      <title>for{;;}与while(true)的困惑</title>
      <link>https://huweicai.com/blog/2018-03/for%E4%B8%8Ewhiletrue%E7%9A%84%E5%9B%B0%E6%83%91/</link>
      <pubDate>Sun, 04 Mar 2018 21:47:00 +0800</pubDate>
      
      <guid>https://huweicai.com/blog/2018-03/for%E4%B8%8Ewhiletrue%E7%9A%84%E5%9B%B0%E6%83%91/</guid>
      <description>最近在阅读JUC源码的时候，由于多线程并发时情况比较复杂，所以源码中经常出现一些无限循环用于等待确保或是某些目的的完成，通常我一般无限循环都是用while(true)，但是我发现在concurrent包中经常用for(;;)来实现。这让我产生了困惑，难道for(;;)会比while(true)性能更好一些吗？于是我决定自己分别编译比较一下。 我编写了如下的程序： public class Test2 { public void whileTest() { int i = 0; while (true) { i++; } } public</description>
    </item>
    
  </channel>
</rss>