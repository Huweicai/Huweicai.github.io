<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Anonymous&#39; Blog</title>
    <link>https://huweicai.com/</link>
    <description>Recent content on Anonymous&#39; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Tue, 22 Dec 2020 23:42:00 +0800</lastBuildDate><atom:link href="https://huweicai.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>VPN是如何工作的</title>
      <link>https://huweicai.com/how-vpn-works/</link>
      <pubDate>Tue, 22 Dec 2020 23:42:00 +0800</pubDate>
      
      <guid>https://huweicai.com/how-vpn-works/</guid>
      <description>VPN 想象一下这两种场景： 你下班家，公司线上一台机器出事故了，这个时候你需要远程到这台机器上来排查并处理问题。 你在其他城市实习，这个时候学校需要选下学期的课了，但是教务网站只对校园网开放。 在这两种场景中，都离不开一种关键的技术：VPN（Virtual Private Network：虚拟局域网）。 VPN提供了一种在公网上安全的加入局域网的方式，可以我们这里就以开源的 OpenConnect VPN 为例，探讨一下 VPN 这种技术是如何安全的将局域网在互</description>
    </item>
    
    <item>
      <title>小米路由器4A百兆版刷OpenWRT</title>
      <link>https://huweicai.com/run-openwrt-on-xiaomi4a100m/</link>
      <pubDate>Tue, 08 Dec 2020 23:47:00 +0800</pubDate>
      
      <guid>https://huweicai.com/run-openwrt-on-xiaomi4a100m/</guid>
      <description>我其实不怎么喜欢写这种教程类的博客，不过苦于刷机过程中资料过少，踩坑过多，特此系统性的捋一下，分享给有缘人，我手上的型号是百兆版的，4A千兆版刷OpenWRT的流程也基本一样，不过需要注意镜像地址什么的自行替换一下。 前提：需要安装 git、python3 以及熟悉基本的终端操作。 找到合适的OpenWRT固件 首先，我们需要一个 OpenWRT 的系统镜像，不同的路由器可能 CPU、网卡等硬件设备都不一样，所以需要不同的指</description>
    </item>
    
    <item>
      <title>Git实现原理</title>
      <link>https://huweicai.com/git-implementation/</link>
      <pubDate>Wed, 11 Nov 2020 01:43:00 +0800</pubDate>
      
      <guid>https://huweicai.com/git-implementation/</guid>
      <description>基本概念 概述 Git 是一个基于快照的文件版本管理系统，其实现原理是为每个文件计算一个 hash 值然后压缩存储到 .git/objects 目录内，普通文件为 blob 对象，而文件夹也会生成一个对象：tree，这样一个版本的文件就能被根目录串联起来，这个版本的再上层会有一个 commit 对象，commit 对象会有一到多个 parent 指针，指向上一个提交，这样就把一个个版本串联了起来。 commit 的上层还有一个概念叫分支，分支是一个指向 commit 的指针，相当于是对这一系列 commit 的抽象。 这是一</description>
    </item>
    
    <item>
      <title>完整网络请求包自底向上分析</title>
      <link>https://huweicai.com/who-network-capture-analysis/</link>
      <pubDate>Wed, 01 Jul 2020 01:47:00 +0800</pubDate>
      
      <guid>https://huweicai.com/who-network-capture-analysis/</guid>
      <description>我们都知道网络是分层的，国际标准化组织将网络划分了七层，定义于 ISO/IEC 7498-1，也就是我们所熟知的 ISO 七层模型。 自底向上分别是：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 而我们所熟知的超文本传输协议（HTTP: HyperText Transfer Protocol）便位于这个模型中的第七层，HTTP 请求包发出的时候会一层一层往下叠加头部知道最终变成最底层的物理信号在网线上传输，那么最终的网络包到底是长什么样呢？我们今</description>
    </item>
    
    <item>
      <title>Golang 如何排查协程泄漏问题</title>
      <link>https://huweicai.com/troubleshotting-goroutine-leeking/</link>
      <pubDate>Fri, 29 May 2020 19:58:00 +0800</pubDate>
      
      <guid>https://huweicai.com/troubleshotting-goroutine-leeking/</guid>
      <description>背景 周所周知，内存泄漏是一个很严重的问题，会导致系统运行占用资源越来越多，无法释放，直至崩溃。所幸 Go 语言是一门 具有垃圾回收的语言，能大大降低遇到内存泄漏的概率，而我们今天要说的是另外一个棘手的问题：协程泄漏。 协程泄漏：顾名思义就是出现了应该释放而没有被释放的协程，导致系统协程数量一直上升。不像对象回收需要引用计数、三色标记等手段，协程的回收是相当简单的，等待协程将代码从头到尾执行完毕之后这一块儿空</description>
    </item>
    
    <item>
      <title>颜色是如何呈现的</title>
      <link>https://huweicai.com/how-color-present/</link>
      <pubDate>Thu, 09 Apr 2020 01:27:11 +0800</pubDate>
      
      <guid>https://huweicai.com/how-color-present/</guid>
      <description>现实的世界是丰富多彩的，然而我们又是怎么将这种色彩呈现到我们的显示器上的呢？ 人眼如何感知色彩 众所周知，光是一种电磁波，可见光是人眼所能处理的一个电磁波频率区间子集，人眼看到事物是通过光来感知的，颜色的本质就是电磁波的频率，不同频率的光即我们语言中所定义的不同种类的颜色。本质上我们的眼睛和雷达并没有任何区别，只是大脑的解码渲染能力强一点罢了。 人的眼睛中有视锥细胞和视杆细胞，视杆细胞负责感受光的强度，</description>
    </item>
    
    <item>
      <title>找出使用最频繁的Shell命令</title>
      <link>https://huweicai.com/most-frequently-command/</link>
      <pubDate>Fri, 20 Mar 2020 19:58:00 +0800</pubDate>
      
      <guid>https://huweicai.com/most-frequently-command/</guid>
      <description>使用最频繁 TOP 10命令： history | awk &amp;#39;{map[$2]++} END { for (a in map )print map[ a ]&amp;#34; &amp;#34; map[ a ]/NR*100 &amp;#34;% &amp;#34; a }&amp;#39;| sort -rn | nl | head 先上成品，然后，我们一步一步分析这行语句都涉及到了命令，它们又是如何拼凑到一块儿完成我们的目的的。 Shell 首先我们需要明确一下 shell 的定义，大家可能经常听到 shell ，shell 脚本这些词，那么 shell 到底是什么呢？ Shell 翻译成中文的意思就是壳，和操作系统内核的核相对应，就是一个基于内核的可操作界面。可操作性界面又分为两种： 图形界面类：Graphi</description>
    </item>
    
    <item>
      <title>进程线程协程的本质区别</title>
      <link>https://huweicai.com/process-thread-goroutine/</link>
      <pubDate>Tue, 17 Mar 2020 01:20:00 +0800</pubDate>
      
      <guid>https://huweicai.com/process-thread-goroutine/</guid>
      <description>现代多任务操作系统通常都会有进程的概念来对任务进行隔离，而为了充分利用多核处理器性能同时又减少进程创建的开销，通常又都会引入更细粒度的调度单元：线程。 我们经常能在教科书上看到对于进程和线程的定义：进程是操作系统分配资源的最小单位，线程是进行调度的最小单元。 广义上的线程分为内核态线程和用户态线程两种，内核态线程受操作系统直接调度可以充分利用硬件资源，而用户态线程实现简单上下文切换开销小，后者也被称</description>
    </item>
    
    <item>
      <title>Go语言sync包实现原理分析</title>
      <link>https://huweicai.com/go-package-sync/</link>
      <pubDate>Fri, 10 Jan 2020 00:30:00 +0800</pubDate>
      
      <guid>https://huweicai.com/go-package-sync/</guid>
      <description>Java 语言中有一个 java.util.Concurrent 包提供了大量的并发工，而 Go 语言中也有这样的角色：sync包。 sync.Mutex 锁实现原理 sync.Mutext 是 Go 提供的一种同步原语，用于表达互斥，不过不推荐在业务中使用，根据 Go 的设计思想，应首先考虑通过传递消息（管道）来共享内存，而不是通过共享内存来传递消息 Mutex 结构体如下，只有两个变量，非常简单： type Mutex struct { state int32 // 状态，bitmap sema uint32 // 信号量 } state 字段是一个位图 第 0 位表示是否加锁 第 1 位表示是否已唤醒 第 2 位表示是否为饥饿模</description>
    </item>
    
    <item>
      <title>Go 多路条件语句 Switch 语法详解</title>
      <link>https://huweicai.com/go-switch/</link>
      <pubDate>Thu, 02 Jan 2020 12:09:00 +0800</pubDate>
      
      <guid>https://huweicai.com/go-switch/</guid>
      <description>Switch 是 Go 语言中一种多路条件语句，一般搭配 case 语句使用。 执行逻辑 一个 switch case 条件结构如下所示： switch simpleStatement; condition { case expression1,expression2: statements case expression3: statements default: statements } 和 if 语句类似，switch 语句也可以在条件语句之前执行一段简短的表达式（可以用于很方便的控制变量的作用域），switch case 开始执行时，会先执行这一个表达式（空也算一种），然后计算出条件语句的值，接着按从上到下，从左到右的顺序一个一个的执行 case 语句的条件表达式，如果值相等的话就会进入执行 case 条件</description>
    </item>
    
    <item>
      <title>MySQL建表选项</title>
      <link>https://huweicai.com/mysql-create-options/</link>
      <pubDate>Wed, 13 Nov 2019 00:13:31 +0800</pubDate>
      
      <guid>https://huweicai.com/mysql-create-options/</guid>
      <description>这是一个很常见的 SQL 建表语句： CREATE TABLE `people` ( `id` int NOT NULL AUTO_INCREMENT, `name` varchar(40) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 SQL 建表语句结构如下： CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name (create_definition,...) [table_options] 我们对照结构可以看到我们的建表语句最后一部分是表选项，而在这里我们指定了两个选项：引擎和字符集，那么总共都有哪些选项可以设置呢？参照MySQL官方文档，我们一起来看看。 AUTO_INCREMENT MySQL 一张表中可以指定一个字段为 auto increment，这样在当这个字段没有指定值时就在当前表最大值的基础上自增，在插入了自增的一</description>
    </item>
    
    <item>
      <title>在线 Markdown 转 PDF 工具评测</title>
      <link>https://huweicai.com/web-markdown-to-pdf-utils/</link>
      <pubDate>Tue, 02 Jul 2019 08:47:11 +0800</pubDate>
      
      <guid>https://huweicai.com/web-markdown-to-pdf-utils/</guid>
      <description>用 Markdown 写了这么久博客，对于这种简约风格还是非常喜欢的，所以在写一些其他文档的时候我也更倾向于这种格式。最近需要写一些 PDF 格式的文档，所以我找了一些在线 Markdown 转 PDF 的网站，不同的网站渲染出来的风格并不一样，我在下面做了一个对比，帮助大家进行选择。 测试数据 # 测试测试 1111111111 / 测试 / 123 Email: test@test.com Test: test Website: https://github.com.cn * * * 123213123 测出测试 真的测试 测试吧 * * * # 二阶段测试 - 真的测试测试 - 真的测试测试/真的测试测试 - 微博：[@Easy](http:</description>
    </item>
    
    <item>
      <title>Java跨平台究竟能跨哪些平台</title>
      <link>https://huweicai.com/java-platforms/</link>
      <pubDate>Mon, 20 May 2019 23:47:00 +0800</pubDate>
      
      <guid>https://huweicai.com/java-platforms/</guid>
      <description>众所周知，Java跨平台的一直被众多Java程序员们津津乐道，“一次编写，到处运行”的设想着实令人心动，虽然会带来一定性能上的问题，但这并不妨碍大家对Java的喜爱，既然都说Java能跨平台，Java 也并不是凭空就能跑在任何机器上，这是不现实的，需要官方针对对应的平台，编译一套对应平台包括 Java 虚拟机（Java Runtime Environment 简称 JRE）在内的 Java 开发工具集（Java Develop Kit，简称 JDK），这样我们编写的 Java 代码才算</description>
    </item>
    
    <item>
      <title>Go知识点杂记</title>
      <link>https://huweicai.com/go-knowledge-points/</link>
      <pubDate>Fri, 05 Apr 2019 23:55:00 +0800</pubDate>
      
      <guid>https://huweicai.com/go-knowledge-points/</guid>
      <description>Go语言的不足 我在使用 Go 语言编程开发时发现的一些问题，记录： 没有泛型，写工具库时很不方便 Go 把错误当成一种函数返回值来处理自有其设计道理，但是一次只能只能处理一个错误则是语法上的不足 编译器不支持尾递归优化，这对于递归代码而言很不友好 strings 库不像 Java 那样直接支持正则 没有三目运算符 官方库提供的锁不支持重入 Go静态链接编译的做法会把二进制包撑的特别大，虽然这带来了较好的可移植性 使用首字母大小写这种隐式的做法来</description>
    </item>
    
    <item>
      <title>Redis FAQ</title>
      <link>https://huweicai.com/redis-faq/</link>
      <pubDate>Fri, 04 Jan 2019 22:43:00 +0800</pubDate>
      
      <guid>https://huweicai.com/redis-faq/</guid>
      <description>Redis 官网 FAQ 翻译以及部分自己生产实践总结的问题 官网FAQ地址 Redos持久化策略：RDB和AOF RDB：数据快照，数据整体快照，吞吐量较大，但单次耗时较长，如果在dump的时候宕机可能会导致数据丢失。 AOF：日志追加，占空间比RDB大，但安全性更好，每秒追加一次日志，丢失数据的可能性会小很多，但是宕机恢复很慢。 而在实际生产环境中，我们通常会将两种持久化策略共同使用，定期进行数据快照，同时保留 AOF 日志，在</description>
    </item>
    
    <item>
      <title>小论计算机Encoding</title>
      <link>https://huweicai.com/computer-encodings/</link>
      <pubDate>Sat, 26 May 2018 12:47:11 +0800</pubDate>
      
      <guid>https://huweicai.com/computer-encodings/</guid>
      <description>乱码问题一直是最让人心烦的一类问题，因为不知从何而来，由何而起，只能一处一处的改编码，运气好了就改成功了，运气不好就继续试，有时候明明把所有能改的地方全改成UTF-8了，却仍然无济于事，着实叫人抓狂。这一切都要从1946年的那个春天说起。 在第一计算机台诞生的时候，那个时候还只有0和1，慢慢的，科学家们厌倦了只有0和1的世界，所以他们就聚在一起开了个会，讨论了讨论，决定按特定的方式将人类语言映射到0</description>
    </item>
    
    <item>
      <title>for{;;}与while(true)的困惑</title>
      <link>https://huweicai.com/confusion-betwwen-forwhiletrue/</link>
      <pubDate>Sun, 04 Mar 2018 21:47:00 +0800</pubDate>
      
      <guid>https://huweicai.com/confusion-betwwen-forwhiletrue/</guid>
      <description>最近在阅读JUC源码的时候，由于多线程并发时情况比较复杂，所以源码中经常出现一些无限循环用于等待确保或是某些目的的完成，通常我一般无限循环都是用while(true)，但是我发现在concurrent包中经常用for(;;)来实现。这让我产生了困惑，难道for(;;)会比while(true)性能更好一些吗？于是我决定自己分别编译比较一下。 我编写了如下的程序： public class Test2 { public void whileTest() { int i = 0; while (true) { i++; } } public</description>
    </item>
    
    <item>
      <title></title>
      <link>https://huweicai.com/personal/go%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huweicai.com/personal/go%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>Go内存示意图 page 内存页面的最小单元，大小为：_PageShift = 13;_PageSize = 1 &amp;lt;&amp;lt; _PageShift = 8KB mheap 是一个全局唯一的对象，代表整个堆，当堆空间不够时，会通过 mmap 系统调用申请一块大小为 64MB 的内存，封装为一个 arena 进行管理。 mheap 中 arenas 数组最多可以管理：4194304 个 arena，每个 arena 64MB，所以 mheap 总共可以管理 256TB 的内存。 type mheap struct { allspans []*mspan // all spans out there arenas [1]*[4194304]*heapArena central [134]struct { // 134 = 57 * 2，有 57 种大小类型的内存 mcentral mcentral } } arena 每个 arena 64 MB // pagesPerArena = 8192 = 8 * 1024 // heapArenaBitmapBytes = 2097152</description>
    </item>
    
  </channel>
</rss>
