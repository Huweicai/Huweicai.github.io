<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CPU on Anonymous&#39; Blog</title>
    <link>https://huweicai.com/tags/cpu/</link>
    <description>Recent content in CPU on Anonymous&#39; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Mon, 05 May 2025 19:58:00 +0800</lastBuildDate><atom:link href="https://huweicai.com/tags/cpu/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>如何极致地压榨一颗 CPU 核心</title>
      <link>https://huweicai.com/cpu-996/</link>
      <pubDate>Mon, 05 May 2025 19:58:00 +0800</pubDate>
      
      <guid>https://huweicai.com/cpu-996/</guid>
      <description>通常当服务端工程师谈论 CPU 核心的时候，更多地时候在乎的是数量而不是质量，比如我们开发了一个 Java 服务的容器需要申请一个 4 核 32 GB 内存的套餐（4C32G），还开发了一个 Golang 服务需要 4C8G 的 quota（我真的不是在黑 Java），但我们绝大多数时候并不会关心底层的 4 个核心来自于 AMD 还是 Intel 品牌的 CPU， 更别说具体什么 Xeon 还是 EPYC 型号了。 因为大部分服务端的问题都可以水平扩容来得到解决，四颗核心不够了，那我们申请六颗核心就好了，</description>
    </item>
    
    <item>
      <title>如何准确的获取CPU占用率[Linux][Go]</title>
      <link>https://huweicai.com/go-linux-get-cpu-usage/</link>
      <pubDate>Fri, 01 Jan 2021 01:20:00 +0800</pubDate>
      
      <guid>https://huweicai.com/go-linux-get-cpu-usage/</guid>
      <description>如果我们想要获取系统的 CPU 占用率，首先，Go 语言本身是没有帮我们封装这样的 API 的，所以我们只能自己通过其他方式直接向操作系统要，而不同的操作系统“要”的方式都不太一样，我们这里主要基于 Linux 场景来分析。 虽然有现成的 ps 和 top 等工具我们可以读到现成的值，但是这些工具也是基于 proc 文件解析的，对于人眼可读性较友好，但是代码解析时就不那么方便了。 PROCESS 文件系统 在许多 Unix 类系统中，都存在一个 procfs (Process File System) 进程文件系统的概念，用于将内</description>
    </item>
    
  </channel>
</rss>
