<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linux on Anonymous&#39; Blog</title>
    <link>https://huweicai.com/tags/linux/</link>
    <description>Recent content in linux on Anonymous&#39; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Mon, 13 Jun 2022 18:20:55 +0800</lastBuildDate><atom:link href="https://huweicai.com/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>聊一聊磁盘</title>
      <link>https://huweicai.com/something-about-disk/</link>
      <pubDate>Mon, 13 Jun 2022 18:20:55 +0800</pubDate>
      
      <guid>https://huweicai.com/something-about-disk/</guid>
      <description>磁盘 磁盘是一种非常常见的持久化存储设备，相较于计算机上另外一种主要的存储设备：内存，磁盘则主要具有断电数据不丢失、容量通常更大、价格低廉等特点；当然我们今天这里主要聊的是广义上的磁盘，而不是特指利用磁性来存储的狭义上的概念。 存储介质 理论上任何能够表达两种状态，且能持久性的保持的东西都可以用来造磁盘；不过我们通常还要考虑成本等其他实际的问题。 我们通常指的磁盘，按照存储介质来分，主要能分为固态硬盘和机</description>
    </item>
    
    <item>
      <title>Linux 内核调试小技巧</title>
      <link>https://huweicai.com/kernel-debug-tips/</link>
      <pubDate>Sun, 13 Mar 2022 00:00:00 +0800</pubDate>
      
      <guid>https://huweicai.com/kernel-debug-tips/</guid>
      <description>Kernel 内核承担了核心的操作系统工作，是当今软件生态的基石，因此了解内核是如何工作的能极大的帮助我们更好地构建用户态系统。 学习软件源代码最好的方式就是边看边 DEBUG，软件 = 代码 + 数据，看代码的同时了解其运行时数据能让我们更好的理解代码。 但内核毕竟不是普通的软件系统，并不是简单的在 IDE 里面一点就能断点调试的，本文分享两种调试内核的小技巧，帮助我们更好的观测其运行时状态。 内核模块 我们通常写的代码都是运行在用</description>
    </item>
    
    <item>
      <title>手动实现一个Linux容器</title>
      <link>https://huweicai.com/run-linux-container-manual/</link>
      <pubDate>Wed, 14 Apr 2021 16:20:00 +0800</pubDate>
      
      <guid>https://huweicai.com/run-linux-container-manual/</guid>
      <description>容器 容器技术的出现，彻底颠覆了传统的应用交付部署方式，交付的边界不再仅限于代码，而是一整套能 run everywhere 的基础设施，正如容器化领域的集大成者 Docker 的标语所言，这是一个新的时代了： Accelerate how you build, share and run modern applications. 容器本质上就是一个软件包，包含了业务服务及其依赖组件，比如我有一个Java服务，依赖了jdk 14.0.1以及几个外部 jar包，同时我们还依赖发行版的一些特性，需要运行在 debian buster发行版上，那么我们可以把这些通通打</description>
    </item>
    
    <item>
      <title>如何准确的获取CPU占用率[Linux][Go]</title>
      <link>https://huweicai.com/go-linux-get-cpu-usage/</link>
      <pubDate>Fri, 01 Jan 2021 01:20:00 +0800</pubDate>
      
      <guid>https://huweicai.com/go-linux-get-cpu-usage/</guid>
      <description>如果我们想要获取系统的 CPU 占用率，首先，Go 语言本身是没有帮我们封装这样的 API 的，所以我们只能自己通过其他方式直接向操作系统要，而不同的操作系统“要”的方式都不太一样，我们这里主要基于 Linux 场景来分析。 虽然有现成的 ps 和 top 等工具我们可以读到现成的值，但是这些工具也是基于 proc 文件解析的，对于人眼可读性较友好，但是代码解析时就不那么方便了。 PROCESS 文件系统 在许多 Unix 类系统中，都存在一个 procfs (Process File System) 进程文件系统的概念，用于将内</description>
    </item>
    
    <item>
      <title>小米路由器4A百兆版刷OpenWRT</title>
      <link>https://huweicai.com/run-openwrt-on-xiaomi4a100m/</link>
      <pubDate>Tue, 08 Dec 2020 23:47:00 +0800</pubDate>
      
      <guid>https://huweicai.com/run-openwrt-on-xiaomi4a100m/</guid>
      <description>我其实不怎么喜欢写这种教程类的博客，不过苦于刷机过程中资料过少，踩坑过多，特此系统性的捋一下，分享给有缘人，我手上的型号是百兆版的，4A千兆版刷OpenWRT的流程也基本一样，不过需要注意镜像地址什么的自行替换一下。 前提：需要安装 git、python3 以及熟悉基本的终端操作。 OpenWRT 首先我们要对 OpenWRT 有一些最基本的概念，OpenWRT 是一种 Linux 发行版，本质上是一个操作系统，和我们的常见的 Windows、And</description>
    </item>
    
    <item>
      <title>找出使用最频繁的Shell命令</title>
      <link>https://huweicai.com/most-frequently-command/</link>
      <pubDate>Fri, 20 Mar 2020 19:58:00 +0800</pubDate>
      
      <guid>https://huweicai.com/most-frequently-command/</guid>
      <description>使用最频繁 TOP 10命令： history | awk &amp;#39;{map[$2]++} END { for (a in map )print map[ a ]&amp;#34; &amp;#34; map[ a ]/NR*100 &amp;#34;% &amp;#34; a }&amp;#39;| sort -rn | nl | head 先上成品，然后，我们一步一步分析这行语句都涉及到了命令，它们又是如何拼凑到一块儿完成我们的目的的。 Shell 首先我们需要明确一下 shell 的定义，大家可能经常听到 shell ，shell 脚本这些词，那么 shell 到底是什么呢？ Shell 翻译成中文的意思就是壳，和操作系统内核的核相对应，就是一个基于内核的可操作界面。可操作性界面又分为两种： 图形界面类：Graphi</description>
    </item>
    
    <item>
      <title>进程线程协程的本质区别</title>
      <link>https://huweicai.com/process-thread-goroutine/</link>
      <pubDate>Tue, 17 Mar 2020 01:20:00 +0800</pubDate>
      
      <guid>https://huweicai.com/process-thread-goroutine/</guid>
      <description>现代多任务操作系统通常都会有进程的概念来对任务进行隔离，而为了充分利用多核处理器性能同时又减少进程创建的开销，通常又都会引入更细粒度的调度单元：线程。 我们经常能在教科书上看到对于进程和线程的定义： 进程是操作系统分配资源的最小单位，线程是进行调度的最小单元。 这句话没错，但是只是从职责上给出的定义，而不是基于底层实现出发的。 广义上的线程分为内核态线程和用户态线程两种，内核态线程受操作系统直接调度可以充</description>
    </item>
    
  </channel>
</rss>
