<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>操作系统 on Anonymous&#39; Blog</title>
    <link>https://huweicai.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
    <description>Recent content in 操作系统 on Anonymous&#39; Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Wed, 30 Dec 2020 01:20:00 +0800</lastBuildDate><atom:link href="https://huweicai.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>如何准确的获取CPU占用率[Linux][Go]</title>
      <link>https://huweicai.com/go-linux-get-cpu-usage/</link>
      <pubDate>Wed, 30 Dec 2020 01:20:00 +0800</pubDate>
      
      <guid>https://huweicai.com/go-linux-get-cpu-usage/</guid>
      <description>如果我们想要获取系统的 CPU 占用率，首先，Go语言本身是没有帮我们封装这样的 API 的，所以我们只能自己通过其他方式直接向操作系统要，而不同的操作系统“要”的方式都不太一样，我们这里主要基于 Linux 场景来分析。 虽然有现成的 ps 和 top 等工具我们可以读到现成的值，但是这些工具也是基于 proc 文件解析的，人眼看可能还好点，要是写代码的话还是直接读系统文件来的方便。 PROCESS 文件系统 在许多 Unix 类系统中，都存在一个 procfs (Process FIle System) 进程文件系统的概念，</description>
    </item>
    
    <item>
      <title>小米路由器4A百兆版刷OpenWRT</title>
      <link>https://huweicai.com/run-openwrt-on-xiaomi4a100m/</link>
      <pubDate>Tue, 08 Dec 2020 23:47:00 +0800</pubDate>
      
      <guid>https://huweicai.com/run-openwrt-on-xiaomi4a100m/</guid>
      <description>我其实不怎么喜欢写这种教程类的博客，不过苦于刷机过程中资料过少，踩坑过多，特此系统性的捋一下，分享给有缘人，我手上的型号是百兆版的，4A千兆版刷OpenWRT的流程也基本一样，不过需要注意镜像地址什么的自行替换一下。 前提：需要安装 git、python3 以及熟悉基本的终端操作。 OpenWRT 首先我们要对 OpenWRT 有一些最基本的概念，OpenWRT 是一种 Linux 发行版，本质上是一个操作系统，和我们的常见的 Windows、And</description>
    </item>
    
    <item>
      <title>进程线程协程的本质区别</title>
      <link>https://huweicai.com/process-thread-goroutine/</link>
      <pubDate>Tue, 17 Mar 2020 01:20:00 +0800</pubDate>
      
      <guid>https://huweicai.com/process-thread-goroutine/</guid>
      <description>现代多任务操作系统通常都会有进程的概念来对任务进行隔离，而为了充分利用多核处理器性能同时又减少进程创建的开销，通常又都会引入更细粒度的调度单元：线程。 我们经常能在教科书上看到对于进程和线程的定义： 进程是操作系统分配资源的最小单位，线程是进行调度的最小单元。 这句话没错，但是只是从职责上给出的定义，而不是基于底层实现出发的。 广义上的线程分为内核态线程和用户态线程两种，内核态线程受操作系统直接调度可以充</description>
    </item>
    
    <item>
      <title>小论计算机Encoding</title>
      <link>https://huweicai.com/computer-encodings/</link>
      <pubDate>Sat, 26 May 2018 12:47:11 +0800</pubDate>
      
      <guid>https://huweicai.com/computer-encodings/</guid>
      <description>乱码问题一直是最让人心烦的一类问题，因为不知从何而来，由何而起，只能一处一处的改编码，运气好了就改成功了，运气不好就继续试，有时候明明把所有能改的地方全改成UTF-8了，却仍然无济于事，着实叫人抓狂。这一切都要从1946年的那个春天说起。 在第一计算机台诞生的时候，那个时候还只有0和1，慢慢的，科学家们厌倦了只有0和1的世界，所以他们就聚在一起开了个会，讨论了讨论，决定按特定的方式将人类语言映射到0</description>
    </item>
    
  </channel>
</rss>
